https://github.com/saiyam1814/Kubernetes-hindi-bootcamp
--To get the process id of nginx serrver
ps aux | grep '[n]ginx' | sort -n -k 2 | head -n 1 | awk '{print $2}'

--lsns -p (process_id) that we geht from above command 

daemon off =   
In Docker, running a process in the foreground means the process is the main task of the container and keeps the container alive as long as it runs. For example:
dockerfile
   CMD ["nginx", "-g", "daemon off;"]
This command keeps Nginx running in the foreground so that the Docker container remains active as long as Nginx is running.

--cd sys/fs/cgroup/memory/system.slice/docker
get the exact memory that we given to container   

--vm containers/linux container/windows containers


---------------------------------------------------------------------

--k8s ==> cluster ==> control plane
tools --> kubadm kops ksctl --these helps in creating k8s cluster (self managed k8s cluster)
         kubectl kubelet    --these helps to interact with cluster(command line utility)

--cat ~/.kube/config  config file were we know how we are communicating with our cluster (home directory/kube/config

----------------------------------------------------------------------
### kube config File ### kubectl config view 
1.clusters -- gives cluster details
2.users -- list of users (credentials) which provide how to communicat with cluster
3.context -- in context we define which user communicate with which cluster 

--kubectl config get-context  gives the list of context * one is the current one
--kubectl config use-context <name of the context>

export KUBECONFIG = path to your config file
or we can use kubectl get nodes --kubeconfig ~/.kube/config 

if we have multiple config files 
export KUBECONFIG =/path/to/first/config:/path/to/second/config:/path/to/third/config

or we can use kubectx (use to change the contex)


--Pod lifecycle 
   Pendig : Find the node waiting for pv to be ready and pvc to bound to it
   ContainerCreating : pulling image, starting it, attaching it
   Running : 
   Error
   Crashloopbackoff : process dying too many times
   Succeeded: job done

spec.os.name -- windows or linux  


----------------------------------------------------------------------------
--Init Container(part3)
   Run till completion
   Can be use to check db is up and runnig ...

--Side Car Container
   ==>1    2    3                                 4
      init init init(with restart policy always)  main container
   side car containers are used to help main container for log collecting, as a proxy, to communicate with other pods

{learn probes}
*pause container hold the ip of pod    

-----------------------------------------------------------------------------
PDB : Pod Discruption Budget The purpose of a PDB is to ensure the availability of critical applications by limiting the number of pod disruptions (e.g., for maintenance or updates) that can occur simultaneously. This helps maintain the desired level of service and stability for applications running in a Kubernetes cluster.

We require pdb because if we want to give roling update then we want min pods to be running 
//kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1   <--here we updated the image to 1.16.1 without downing all the pods


------------------------------------------------------------------------------
Request /Limit
   Memeory limit == request
   CPU request (limit not needed Linux CFS Completely Fair Scheduler)
kind:LimitRange  in this we give resource allocation on the basis of name-space
QOS Quality of Service Class
      Guranteed request=limit
      Burstable request/limit not defined
      Best Effort nothing defined
   So when node is draing first best effort pods will be evicted
   resource{} <-resource section
------------------------------------------------------------------------------
kind:ResorceQuota
   we can define how man pods we can create cpu memory ...
kind: PriorityClass
   we can set priority so that our pods we run with high priority so that system will be available 


{learn probes} part 6
*nodeAffinity -- helps to schedule pods on particular node with provided criteria

Taint & Toleration(opposite of nodeAffinity)
   we apply taint on node 
      effect -No Schedule : donot schedule on this node
             -Prefer No Schedule : if nothing available then can schedule
             -No Execute   :Nothing can be execute on that node
Or if we want to schedule on a particular node then in spec:
                                                         nodeName:node01  {it we always schedule on node01}

------------------------------------------------------------------------------

Deployment ==>ReplicaSet ==>Pods
   Strategy:
      RollingUpdateStrategy
      kubectl set image deploy <deployment-name> nginx=nginx:1.16.1 {image:tag} 

      Recreate -->update all pods at once  there is downtime   

      Blue Green                                  {by use the concept of heterogeneous labels}
      Canary 90% traffic ->v1 10% traffic ->v2


------------------------------------------------------------------------------
Config Maps & Secrets
   
   ConfigMaps : Non-confidential data 
   ConfigMapAndSecretsChangeDetectionStrategy -->kubelet setting {immutable = ture , so that we cannot update it only recreate it or delete it }

   Secrets: pull image form pvt repo {learn csi drivers, external secrets operator}
      multiple types but for docker we use kubernetes.io/dockerconfigjson    ~/.docker/config.json
      **to get password 
         -kubectl get secret <secret-name> -oyaml {you will get the password}
         -echo "<your password>" | base64 -d

